#!KAMAILIO

debug=2
log_stderror=no
children=4
enable_sctp=no

listen=udp:0.0.0.0:5060 advertise 124.220.58.234:5060
# Enable TCP listeners for SIP on 5060 and external TCP on 5080
listen=tcp:0.0.0.0:5060 advertise 124.220.58.234:5060
listen=tcp:0.0.0.0:5080 advertise 124.220.58.234:5080
alias="sip.weiyuai.cn"

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

# Modules (tm must be loaded before modules depending on it)
loadmodule "tm.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "sanity.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "pv.so"
loadmodule "xlog.so"
loadmodule "dispatcher.so"
loadmodule "nathelper.so"

# Module params
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 0)

modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

modparam("sanity", "autodrop", 0)

modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_probing_mode", 1)

modparam("nathelper", "received_avp", "$avp(rcv)")

route[DISPATCH] {
    # Select upstream set based on received transport and port
    if ($proto == "udp" && $Rp == 5060) {
        if(!ds_select_dst(1, 0)) { send_reply(500, "No Upstream UDP5060"); exit; }
    } else if ($proto == "tcp" && $Rp == 5060) {
        if(!ds_select_dst(2, 0)) { send_reply(500, "No Upstream TCP5060"); exit; }
    } else if ($proto == "tcp" && $Rp == 5080) {
        if(!ds_select_dst(3, 0)) { send_reply(500, "No Upstream TCP5080"); exit; }
    } else {
        if(!ds_select_dst(1, 0)) { send_reply(500, "No Upstream"); exit; }
    }
    t_on_reply("NAT_REPLY");
    if(!t_relay()) {
        sl_reply_error();
    }
    exit;
}

onreply_route[NAT_REPLY] {
    if (isflagset(5)) {
        # Only attempt to fix Contact on provisional/success replies that actually carry Contact
        if ($rs >= 100 && $rs < 300 && is_present_hf("Contact")) {
            fix_nated_contact();
        }
    }
}

request_route {
    if (!sanity_check("1511", "7")) {
        send_reply(400, "Bad Request");
        exit;
    }

    # Basic NAT handling
    force_rport();
    if (nat_uac_test(19)) {
        setflag(5);
        if (is_present_hf("Contact")) {
            fix_nated_contact();
        }
    }

    # Stay in the signaling path
    record_route();

    route(DISPATCH);
}
