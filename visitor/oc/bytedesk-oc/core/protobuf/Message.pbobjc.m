// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Message.pbobjc.h"
#import "User.pbobjc.h"
#import "Thread.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Extra);
GPBObjCClassDeclaration(File);
GPBObjCClassDeclaration(Image);
GPBObjCClassDeclaration(Invite);
GPBObjCClassDeclaration(Link);
GPBObjCClassDeclaration(Location);
GPBObjCClassDeclaration(Message);
GPBObjCClassDeclaration(Notice);
GPBObjCClassDeclaration(Preview);
GPBObjCClassDeclaration(Recall);
GPBObjCClassDeclaration(Receipt);
GPBObjCClassDeclaration(Reply);
GPBObjCClassDeclaration(Text);
GPBObjCClassDeclaration(Thread);
GPBObjCClassDeclaration(Transfer);
GPBObjCClassDeclaration(User);
GPBObjCClassDeclaration(Video);
GPBObjCClassDeclaration(Voice);

#pragma mark - MessageRoot

@implementation MessageRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MessageRoot_FileDescriptor

static GPBFileDescriptor *MessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Text

@implementation Text

@dynamic content;

typedef struct Text__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} Text__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = Text_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Text__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Text class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Text__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Image

@implementation Image

@dynamic mediaId;
@dynamic picURL;
@dynamic imageURL;

typedef struct Image__storage_ {
  uint32_t _has_storage_[1];
  NSString *mediaId;
  NSString *picURL;
  NSString *imageURL;
} Image__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mediaId",
        .dataTypeSpecific.clazz = Nil,
        .number = Image_FieldNumber_MediaId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Image__storage_, mediaId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "picURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Image_FieldNumber_PicURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Image__storage_, picURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Image_FieldNumber_ImageURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Image__storage_, imageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Image class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Image__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\004!!\000\003\006!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - File

@implementation File

@dynamic fileURL;
@dynamic fileName;
@dynamic fileSize;

typedef struct File__storage_ {
  uint32_t _has_storage_[1];
  NSString *fileURL;
  NSString *fileName;
  NSString *fileSize;
} File__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileURL",
        .dataTypeSpecific.clazz = Nil,
        .number = File_FieldNumber_FileURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(File__storage_, fileURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.clazz = Nil,
        .number = File_FieldNumber_FileName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(File__storage_, fileName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.clazz = Nil,
        .number = File_FieldNumber_FileSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(File__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[File class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(File__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\005!!\000\002\010\000\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Voice

@implementation Voice

@dynamic mediaId;
@dynamic format;
@dynamic voiceURL;
@dynamic length;
@dynamic played;

typedef struct Voice__storage_ {
  uint32_t _has_storage_[1];
  int32_t length;
  NSString *mediaId;
  NSString *format;
  NSString *voiceURL;
} Voice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mediaId",
        .dataTypeSpecific.clazz = Nil,
        .number = Voice_FieldNumber_MediaId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Voice__storage_, mediaId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "format",
        .dataTypeSpecific.clazz = Nil,
        .number = Voice_FieldNumber_Format,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Voice__storage_, format),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Voice_FieldNumber_VoiceURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Voice__storage_, voiceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "length",
        .dataTypeSpecific.clazz = Nil,
        .number = Voice_FieldNumber_Length,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Voice__storage_, length),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "played",
        .dataTypeSpecific.clazz = Nil,
        .number = Voice_FieldNumber_Played,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Voice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Voice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\003\006!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Video

@implementation Video

@dynamic mediaId;
@dynamic thumbMediaId;
@dynamic videoOrShortURL;
@dynamic videoOrShortThumbURL;
@dynamic title;
@dynamic description_p;

typedef struct Video__storage_ {
  uint32_t _has_storage_[1];
  NSString *mediaId;
  NSString *thumbMediaId;
  NSString *videoOrShortURL;
  NSString *videoOrShortThumbURL;
  NSString *title;
  NSString *description_p;
} Video__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mediaId",
        .dataTypeSpecific.clazz = Nil,
        .number = Video_FieldNumber_MediaId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Video__storage_, mediaId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbMediaId",
        .dataTypeSpecific.clazz = Nil,
        .number = Video_FieldNumber_ThumbMediaId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Video__storage_, thumbMediaId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoOrShortURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Video_FieldNumber_VideoOrShortURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Video__storage_, videoOrShortURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoOrShortThumbURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Video_FieldNumber_VideoOrShortThumbURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Video__storage_, videoOrShortThumbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = Video_FieldNumber_Title,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Video__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Video_FieldNumber_Description_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Video__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Video class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Video__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\007\000\002\014\000\003\r!!\000\004\022!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Location

@implementation Location

@dynamic locationX;
@dynamic locationY;
@dynamic scale;
@dynamic label;

typedef struct Location__storage_ {
  uint32_t _has_storage_[1];
  NSString *locationX;
  NSString *locationY;
  NSString *scale;
  NSString *label;
} Location__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "locationX",
        .dataTypeSpecific.clazz = Nil,
        .number = Location_FieldNumber_LocationX,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Location__storage_, locationX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locationY",
        .dataTypeSpecific.clazz = Nil,
        .number = Location_FieldNumber_LocationY,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Location__storage_, locationY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scale",
        .dataTypeSpecific.clazz = Nil,
        .number = Location_FieldNumber_Scale,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Location__storage_, scale),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = Nil,
        .number = Location_FieldNumber_Label,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Location__storage_, label),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Location class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Location__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Link

@implementation Link

@dynamic title;
@dynamic description_p;
@dynamic URL;

typedef struct Link__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *description_p;
  NSString *URL;
} Link__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = Link_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Link__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Link_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Link__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = Link_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Link__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Link class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Link__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Receipt

@implementation Receipt

@dynamic mid;
@dynamic status;

typedef struct Receipt__storage_ {
  uint32_t _has_storage_[1];
  NSString *mid;
  NSString *status;
} Receipt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = Nil,
        .number = Receipt_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Receipt__storage_, mid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = Receipt_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Receipt__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Receipt class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Receipt__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Reply

@implementation Reply

@dynamic mid;
@dynamic content;

typedef struct Reply__storage_ {
  uint32_t _has_storage_[1];
  NSString *mid;
  NSString *content;
} Reply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = Nil,
        .number = Reply_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Reply__storage_, mid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = Reply_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Reply__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Reply class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Reply__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Preview

@implementation Preview

@dynamic content;

typedef struct Preview__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} Preview__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = Preview_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Preview__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Preview class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Preview__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Recall

@implementation Recall

@dynamic mid;

typedef struct Recall__storage_ {
  uint32_t _has_storage_[1];
  NSString *mid;
} Recall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = Nil,
        .number = Recall_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Recall__storage_, mid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Recall class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Recall__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transfer

@implementation Transfer

@dynamic topic;
@dynamic type;
@dynamic content;
@dynamic accept;

typedef struct Transfer__storage_ {
  uint32_t _has_storage_[1];
  NSString *topic;
  NSString *type;
  NSString *content;
} Transfer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topic",
        .dataTypeSpecific.clazz = Nil,
        .number = Transfer_FieldNumber_Topic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transfer__storage_, topic),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = Transfer_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transfer__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = Transfer_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transfer__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accept",
        .dataTypeSpecific.clazz = Nil,
        .number = Transfer_FieldNumber_Accept,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transfer class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transfer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Invite

@implementation Invite

@dynamic topic;
@dynamic type;
@dynamic content;
@dynamic accept;

typedef struct Invite__storage_ {
  uint32_t _has_storage_[1];
  NSString *topic;
  NSString *type;
  NSString *content;
} Invite__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topic",
        .dataTypeSpecific.clazz = Nil,
        .number = Invite_FieldNumber_Topic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Invite__storage_, topic),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = Invite_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Invite__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = Invite_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Invite__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accept",
        .dataTypeSpecific.clazz = Nil,
        .number = Invite_FieldNumber_Accept,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Invite class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Invite__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Notice

@implementation Notice

@dynamic topic;
@dynamic type;
@dynamic content;

typedef struct Notice__storage_ {
  uint32_t _has_storage_[1];
  NSString *topic;
  NSString *type;
  NSString *content;
} Notice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topic",
        .dataTypeSpecific.clazz = Nil,
        .number = Notice_FieldNumber_Topic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Notice__storage_, topic),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = Notice_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Notice__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = Notice_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Notice__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Notice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Notice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Extra

@implementation Extra

@dynamic content;

typedef struct Extra__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} Extra__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = Extra_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Extra__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Extra class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Extra__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Message

@implementation Message

@dynamic bodyOneOfCase;
@dynamic mid;
@dynamic status;
@dynamic timestamp;
@dynamic client;
@dynamic version;
@dynamic type;
@dynamic hasUser, user;
@dynamic text;
@dynamic image;
@dynamic file;
@dynamic voice;
@dynamic video;
@dynamic location;
@dynamic link;
@dynamic receipt;
@dynamic reply;
@dynamic preview;
@dynamic recall;
@dynamic transfer;
@dynamic invite;
@dynamic notice;
@dynamic extra;
@dynamic hasThread, thread;
@dynamic encrypted;

typedef struct Message__storage_ {
  uint32_t _has_storage_[2];
  NSString *mid;
  NSString *status;
  NSString *timestamp;
  NSString *client;
  NSString *version;
  NSString *type;
  User *user;
  Text *text;
  Image *image;
  File *file;
  Voice *voice;
  Video *video;
  Location *location;
  Link *link;
  Receipt *receipt;
  Reply *reply;
  Preview *preview;
  Recall *recall;
  Transfer *transfer;
  Invite *invite;
  Notice *notice;
  Extra *extra;
  Thread *thread;
} Message__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.clazz = Nil,
        .number = Message_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Message__storage_, mid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = Message_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Message__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = Message_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Message__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "client",
        .dataTypeSpecific.clazz = Nil,
        .number = Message_FieldNumber_Client,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Message__storage_, client),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = Message_FieldNumber_Version,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Message__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = Message_FieldNumber_Type,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Message__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.clazz = GPBObjCClass(User),
        .number = Message_FieldNumber_User,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Message__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(Text),
        .number = Message_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(Image),
        .number = Message_FieldNumber_Image,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "file",
        .dataTypeSpecific.clazz = GPBObjCClass(File),
        .number = Message_FieldNumber_File,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, file),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(Voice),
        .number = Message_FieldNumber_Voice,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.clazz = GPBObjCClass(Video),
        .number = Message_FieldNumber_Video,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "location",
        .dataTypeSpecific.clazz = GPBObjCClass(Location),
        .number = Message_FieldNumber_Location,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "link",
        .dataTypeSpecific.clazz = GPBObjCClass(Link),
        .number = Message_FieldNumber_Link,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, link),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.clazz = GPBObjCClass(Receipt),
        .number = Message_FieldNumber_Receipt,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, receipt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reply",
        .dataTypeSpecific.clazz = GPBObjCClass(Reply),
        .number = Message_FieldNumber_Reply,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, reply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preview",
        .dataTypeSpecific.clazz = GPBObjCClass(Preview),
        .number = Message_FieldNumber_Preview,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, preview),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recall",
        .dataTypeSpecific.clazz = GPBObjCClass(Recall),
        .number = Message_FieldNumber_Recall,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, recall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transfer",
        .dataTypeSpecific.clazz = GPBObjCClass(Transfer),
        .number = Message_FieldNumber_Transfer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, transfer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "invite",
        .dataTypeSpecific.clazz = GPBObjCClass(Invite),
        .number = Message_FieldNumber_Invite,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, invite),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notice",
        .dataTypeSpecific.clazz = GPBObjCClass(Notice),
        .number = Message_FieldNumber_Notice,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, notice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extra",
        .dataTypeSpecific.clazz = GPBObjCClass(Extra),
        .number = Message_FieldNumber_Extra,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Message__storage_, extra),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "thread",
        .dataTypeSpecific.clazz = GPBObjCClass(Thread),
        .number = Message_FieldNumber_Thread,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Message__storage_, thread),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "encrypted",
        .dataTypeSpecific.clazz = Nil,
        .number = Message_FieldNumber_Encrypted,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Message class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Message__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Message_ClearBodyOneOfCase(Message *message) {
  GPBDescriptor *descriptor = [Message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - MessageList

@implementation MessageList

@dynamic listArray, listArray_Count;

typedef struct MessageList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} MessageList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Message),
        .number = MessageList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageList class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
