// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 消息体内容
struct Bytedesk_Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 文本消息内容
  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Image {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaID: String = String()

  /// 图片消息, 微信pic_url，web版容易引起跨域访问问题，所以要使用image_url
  var picURL: String = String()

  /// 存储在自己服务器之后的url
  var imageURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 文件消息类型，文件url, 文件类型通过format标示
  var fileURL: String = String()

  /// 文件名
  var fileName: String = String()

  /// 文件大小
  var fileSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Voice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 语音消息，图片+语音+视频+短视频 公用字段
  var mediaID: String = String()

  /// 语音格式amr等
  var format: String = String()

  /// 语音url
  var voiceURL: String = String()

  /// 语音长度
  ///    google.protobuf.Int32Value length = 4;
  var length: Int32 = 0

  /// 是否已经播放过
  var played: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Video {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaID: String = String()

  /// 视频和短视频
  var thumbMediaID: String = String()

  var videoOrShortURL: String = String()

  var videoOrShortThumbURL: String = String()

  var title: String = String()

  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 地理位置消息
  var locationX: String = String()

  var locationY: String = String()

  var scale: String = String()

  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Link {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 链接消息
  var title: String = String()

  var description_p: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Receipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息回执
  var mid: String = String()

  /// 状态
  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Reply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息回复
  var mid: String = String()

  /// 内容
  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Preview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息预览
  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Recall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息撤回
  var mid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Transfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接收者的topic
  var topic: String = String()

  /// 类型：转接会话给 技能组 or 个人
  var type: String = String()

  /// 附言
  var content: String = String()

  /// 转接结果：接受 or 拒绝
  var accept: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Invite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接收者的topic
  var topic: String = String()

  /// 类型：邀请会话给 技能组 or 个人
  var type: String = String()

  /// 附言
  var content: String = String()

  /// 转接结果：接受 or 拒绝
  var accept: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Notice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// topic
  var topic: String = String()

  /// 会议提醒等
  var type: String = String()

  /// 内容
  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bytedesk_Extra {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 开发者自定义字段内容
  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 消息三要素：1. 谁发送的消息？ 2. 发送给谁的消息？ 3. 发送的消息内容是什么？
struct Bytedesk_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 唯一ID/localId=mid
  var mid: String {
    get {return _storage._mid}
    set {_uniqueStorage()._mid = newValue}
  }

  /// 主题：消息接收者为订阅此topic的人
  /// string topic = 2;
  /// 消息发送状态
  var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// 时间戳
  /// string createdAt = 4;
  var timestamp: String {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  /// mqtt clientId
  /// string clientId = 5;
  /// 消息来源客户端ew
  var client: String {
    get {return _storage._client}
    set {_uniqueStorage()._client = newValue}
  }

  /// 消息版本
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// 消息类型
  ///    MessageType type = 8;
  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// 1. 谁发送的消息？ 消息发送者
  var user: Bytedesk_User {
    get {return _storage._user ?? Bytedesk_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// 3. 发送的消息内容是什么？消息体内容，至少设置其中一种
  var body: OneOf_Body? {
    get {return _storage._body}
    set {_uniqueStorage()._body = newValue}
  }

  var text: Bytedesk_Text {
    get {
      if case .text(let v)? = _storage._body {return v}
      return Bytedesk_Text()
    }
    set {_uniqueStorage()._body = .text(newValue)}
  }

  var image: Bytedesk_Image {
    get {
      if case .image(let v)? = _storage._body {return v}
      return Bytedesk_Image()
    }
    set {_uniqueStorage()._body = .image(newValue)}
  }

  var file: Bytedesk_File {
    get {
      if case .file(let v)? = _storage._body {return v}
      return Bytedesk_File()
    }
    set {_uniqueStorage()._body = .file(newValue)}
  }

  var voice: Bytedesk_Voice {
    get {
      if case .voice(let v)? = _storage._body {return v}
      return Bytedesk_Voice()
    }
    set {_uniqueStorage()._body = .voice(newValue)}
  }

  var video: Bytedesk_Video {
    get {
      if case .video(let v)? = _storage._body {return v}
      return Bytedesk_Video()
    }
    set {_uniqueStorage()._body = .video(newValue)}
  }

  var location: Bytedesk_Location {
    get {
      if case .location(let v)? = _storage._body {return v}
      return Bytedesk_Location()
    }
    set {_uniqueStorage()._body = .location(newValue)}
  }

  var link: Bytedesk_Link {
    get {
      if case .link(let v)? = _storage._body {return v}
      return Bytedesk_Link()
    }
    set {_uniqueStorage()._body = .link(newValue)}
  }

  var receipt: Bytedesk_Receipt {
    get {
      if case .receipt(let v)? = _storage._body {return v}
      return Bytedesk_Receipt()
    }
    set {_uniqueStorage()._body = .receipt(newValue)}
  }

  var reply: Bytedesk_Reply {
    get {
      if case .reply(let v)? = _storage._body {return v}
      return Bytedesk_Reply()
    }
    set {_uniqueStorage()._body = .reply(newValue)}
  }

  var preview: Bytedesk_Preview {
    get {
      if case .preview(let v)? = _storage._body {return v}
      return Bytedesk_Preview()
    }
    set {_uniqueStorage()._body = .preview(newValue)}
  }

  var recall: Bytedesk_Recall {
    get {
      if case .recall(let v)? = _storage._body {return v}
      return Bytedesk_Recall()
    }
    set {_uniqueStorage()._body = .recall(newValue)}
  }

  var transfer: Bytedesk_Transfer {
    get {
      if case .transfer(let v)? = _storage._body {return v}
      return Bytedesk_Transfer()
    }
    set {_uniqueStorage()._body = .transfer(newValue)}
  }

  var invite: Bytedesk_Invite {
    get {
      if case .invite(let v)? = _storage._body {return v}
      return Bytedesk_Invite()
    }
    set {_uniqueStorage()._body = .invite(newValue)}
  }

  var notice: Bytedesk_Notice {
    get {
      if case .notice(let v)? = _storage._body {return v}
      return Bytedesk_Notice()
    }
    set {_uniqueStorage()._body = .notice(newValue)}
  }

  var extra: Bytedesk_Extra {
    get {
      if case .extra(let v)? = _storage._body {return v}
      return Bytedesk_Extra()
    }
    set {_uniqueStorage()._body = .extra(newValue)}
  }

  /// 2. 发送给谁的消息？客服会话/一对一会话/群组会话
  var thread: Bytedesk_Thread {
    get {return _storage._thread ?? Bytedesk_Thread()}
    set {_uniqueStorage()._thread = newValue}
  }
  /// Returns true if `thread` has been explicitly set.
  var hasThread: Bool {return _storage._thread != nil}
  /// Clears the value of `thread`. Subsequent reads from it will return its default value.
  mutating func clearThread() {_uniqueStorage()._thread = nil}

  /// 是否加密，true为加密，false为明文
  var encrypted: Bool {
    get {return _storage._encrypted}
    set {_uniqueStorage()._encrypted = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// 3. 发送的消息内容是什么？消息体内容，至少设置其中一种
  enum OneOf_Body: Equatable {
    case text(Bytedesk_Text)
    case image(Bytedesk_Image)
    case file(Bytedesk_File)
    case voice(Bytedesk_Voice)
    case video(Bytedesk_Video)
    case location(Bytedesk_Location)
    case link(Bytedesk_Link)
    case receipt(Bytedesk_Receipt)
    case reply(Bytedesk_Reply)
    case preview(Bytedesk_Preview)
    case recall(Bytedesk_Recall)
    case transfer(Bytedesk_Transfer)
    case invite(Bytedesk_Invite)
    case notice(Bytedesk_Notice)
    case extra(Bytedesk_Extra)

  #if !swift(>=4.1)
    static func ==(lhs: Bytedesk_Message.OneOf_Body, rhs: Bytedesk_Message.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.voice, .voice): return {
        guard case .voice(let l) = lhs, case .voice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.video, .video): return {
        guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.link, .link): return {
        guard case .link(let l) = lhs, case .link(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receipt, .receipt): return {
        guard case .receipt(let l) = lhs, case .receipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reply, .reply): return {
        guard case .reply(let l) = lhs, case .reply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preview, .preview): return {
        guard case .preview(let l) = lhs, case .preview(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recall, .recall): return {
        guard case .recall(let l) = lhs, case .recall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transfer, .transfer): return {
        guard case .transfer(let l) = lhs, case .transfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invite, .invite): return {
        guard case .invite(let l) = lhs, case .invite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notice, .notice): return {
        guard case .notice(let l) = lhs, case .notice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.extra, .extra): return {
        guard case .extra(let l) = lhs, case .extra(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 列表
struct Bytedesk_MessageList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var list: [Bytedesk_Message] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Bytedesk_Text: @unchecked Sendable {}
extension Bytedesk_Image: @unchecked Sendable {}
extension Bytedesk_File: @unchecked Sendable {}
extension Bytedesk_Voice: @unchecked Sendable {}
extension Bytedesk_Video: @unchecked Sendable {}
extension Bytedesk_Location: @unchecked Sendable {}
extension Bytedesk_Link: @unchecked Sendable {}
extension Bytedesk_Receipt: @unchecked Sendable {}
extension Bytedesk_Reply: @unchecked Sendable {}
extension Bytedesk_Preview: @unchecked Sendable {}
extension Bytedesk_Recall: @unchecked Sendable {}
extension Bytedesk_Transfer: @unchecked Sendable {}
extension Bytedesk_Invite: @unchecked Sendable {}
extension Bytedesk_Notice: @unchecked Sendable {}
extension Bytedesk_Extra: @unchecked Sendable {}
extension Bytedesk_Message: @unchecked Sendable {}
extension Bytedesk_Message.OneOf_Body: @unchecked Sendable {}
extension Bytedesk_MessageList: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Bytedesk"

extension Bytedesk_Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Text, rhs: Bytedesk_Text) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Image"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaId"),
    2: .same(proto: "picUrl"),
    3: .same(proto: "imageUrl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.picURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaID, fieldNumber: 1)
    }
    if !self.picURL.isEmpty {
      try visitor.visitSingularStringField(value: self.picURL, fieldNumber: 2)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Image, rhs: Bytedesk_Image) -> Bool {
    if lhs.mediaID != rhs.mediaID {return false}
    if lhs.picURL != rhs.picURL {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileUrl"),
    2: .same(proto: "fileName"),
    3: .same(proto: "fileSize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fileSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fileURL, fieldNumber: 1)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 2)
    }
    if !self.fileSize.isEmpty {
      try visitor.visitSingularStringField(value: self.fileSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_File, rhs: Bytedesk_File) -> Bool {
    if lhs.fileURL != rhs.fileURL {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Voice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Voice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaId"),
    2: .same(proto: "format"),
    3: .same(proto: "voiceUrl"),
    4: .same(proto: "length"),
    5: .same(proto: "played"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.voiceURL) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.played) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaID, fieldNumber: 1)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 2)
    }
    if !self.voiceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.voiceURL, fieldNumber: 3)
    }
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 4)
    }
    if self.played != false {
      try visitor.visitSingularBoolField(value: self.played, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Voice, rhs: Bytedesk_Voice) -> Bool {
    if lhs.mediaID != rhs.mediaID {return false}
    if lhs.format != rhs.format {return false}
    if lhs.voiceURL != rhs.voiceURL {return false}
    if lhs.length != rhs.length {return false}
    if lhs.played != rhs.played {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Video: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Video"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaId"),
    2: .same(proto: "thumbMediaId"),
    3: .same(proto: "videoOrShortUrl"),
    4: .same(proto: "videoOrShortThumbUrl"),
    5: .same(proto: "title"),
    6: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.thumbMediaID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.videoOrShortURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoOrShortThumbURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaID, fieldNumber: 1)
    }
    if !self.thumbMediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbMediaID, fieldNumber: 2)
    }
    if !self.videoOrShortURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoOrShortURL, fieldNumber: 3)
    }
    if !self.videoOrShortThumbURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoOrShortThumbURL, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Video, rhs: Bytedesk_Video) -> Bool {
    if lhs.mediaID != rhs.mediaID {return false}
    if lhs.thumbMediaID != rhs.thumbMediaID {return false}
    if lhs.videoOrShortURL != rhs.videoOrShortURL {return false}
    if lhs.videoOrShortThumbURL != rhs.videoOrShortThumbURL {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locationX"),
    2: .same(proto: "locationY"),
    3: .same(proto: "scale"),
    4: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.locationX) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.locationY) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scale) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locationX.isEmpty {
      try visitor.visitSingularStringField(value: self.locationX, fieldNumber: 1)
    }
    if !self.locationY.isEmpty {
      try visitor.visitSingularStringField(value: self.locationY, fieldNumber: 2)
    }
    if !self.scale.isEmpty {
      try visitor.visitSingularStringField(value: self.scale, fieldNumber: 3)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Location, rhs: Bytedesk_Location) -> Bool {
    if lhs.locationX != rhs.locationX {return false}
    if lhs.locationY != rhs.locationY {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Link"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Link, rhs: Bytedesk_Link) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Receipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Receipt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mid"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mid.isEmpty {
      try visitor.visitSingularStringField(value: self.mid, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Receipt, rhs: Bytedesk_Receipt) -> Bool {
    if lhs.mid != rhs.mid {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mid"),
    2: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mid.isEmpty {
      try visitor.visitSingularStringField(value: self.mid, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Reply, rhs: Bytedesk_Reply) -> Bool {
    if lhs.mid != rhs.mid {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Preview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Preview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Preview, rhs: Bytedesk_Preview) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Recall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mid.isEmpty {
      try visitor.visitSingularStringField(value: self.mid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Recall, rhs: Bytedesk_Recall) -> Bool {
    if lhs.mid != rhs.mid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Transfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "type"),
    3: .same(proto: "content"),
    4: .same(proto: "accept"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.accept) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    if self.accept != false {
      try visitor.visitSingularBoolField(value: self.accept, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Transfer, rhs: Bytedesk_Transfer) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.type != rhs.type {return false}
    if lhs.content != rhs.content {return false}
    if lhs.accept != rhs.accept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Invite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "type"),
    3: .same(proto: "content"),
    4: .same(proto: "accept"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.accept) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    if self.accept != false {
      try visitor.visitSingularBoolField(value: self.accept, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Invite, rhs: Bytedesk_Invite) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.type != rhs.type {return false}
    if lhs.content != rhs.content {return false}
    if lhs.accept != rhs.accept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Notice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Notice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "type"),
    3: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Notice, rhs: Bytedesk_Notice) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.type != rhs.type {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Extra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Extra"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Extra, rhs: Bytedesk_Extra) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mid"),
    3: .same(proto: "status"),
    4: .same(proto: "timestamp"),
    6: .same(proto: "client"),
    7: .same(proto: "version"),
    8: .same(proto: "type"),
    9: .same(proto: "user"),
    10: .same(proto: "text"),
    11: .same(proto: "image"),
    12: .same(proto: "file"),
    13: .same(proto: "voice"),
    14: .same(proto: "video"),
    15: .same(proto: "location"),
    16: .same(proto: "link"),
    17: .same(proto: "receipt"),
    18: .same(proto: "reply"),
    19: .same(proto: "preview"),
    20: .same(proto: "recall"),
    21: .same(proto: "transfer"),
    22: .same(proto: "invite"),
    23: .same(proto: "notice"),
    30: .same(proto: "extra"),
    31: .same(proto: "thread"),
    32: .same(proto: "encrypted"),
  ]

  fileprivate class _StorageClass {
    var _mid: String = String()
    var _status: String = String()
    var _timestamp: String = String()
    var _client: String = String()
    var _version: String = String()
    var _type: String = String()
    var _user: Bytedesk_User? = nil
    var _body: Bytedesk_Message.OneOf_Body?
    var _thread: Bytedesk_Thread? = nil
    var _encrypted: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mid = source._mid
      _status = source._status
      _timestamp = source._timestamp
      _client = source._client
      _version = source._version
      _type = source._type
      _user = source._user
      _body = source._body
      _thread = source._thread
      _encrypted = source._encrypted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._mid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._timestamp) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._client) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 10: try {
          var v: Bytedesk_Text?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .text(v)
          }
        }()
        case 11: try {
          var v: Bytedesk_Image?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .image(v)
          }
        }()
        case 12: try {
          var v: Bytedesk_File?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .file(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .file(v)
          }
        }()
        case 13: try {
          var v: Bytedesk_Voice?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .voice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .voice(v)
          }
        }()
        case 14: try {
          var v: Bytedesk_Video?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .video(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .video(v)
          }
        }()
        case 15: try {
          var v: Bytedesk_Location?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .location(v)
          }
        }()
        case 16: try {
          var v: Bytedesk_Link?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .link(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .link(v)
          }
        }()
        case 17: try {
          var v: Bytedesk_Receipt?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .receipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .receipt(v)
          }
        }()
        case 18: try {
          var v: Bytedesk_Reply?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .reply(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .reply(v)
          }
        }()
        case 19: try {
          var v: Bytedesk_Preview?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .preview(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .preview(v)
          }
        }()
        case 20: try {
          var v: Bytedesk_Recall?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .recall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .recall(v)
          }
        }()
        case 21: try {
          var v: Bytedesk_Transfer?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .transfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .transfer(v)
          }
        }()
        case 22: try {
          var v: Bytedesk_Invite?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .invite(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .invite(v)
          }
        }()
        case 23: try {
          var v: Bytedesk_Notice?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .notice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .notice(v)
          }
        }()
        case 30: try {
          var v: Bytedesk_Extra?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .extra(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .extra(v)
          }
        }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._thread) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._encrypted) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._mid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mid, fieldNumber: 1)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 3)
      }
      if !_storage._timestamp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._timestamp, fieldNumber: 4)
      }
      if !_storage._client.isEmpty {
        try visitor.visitSingularStringField(value: _storage._client, fieldNumber: 6)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 7)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 8)
      }
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      switch _storage._body {
      case .text?: try {
        guard case .text(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .image?: try {
        guard case .image(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .file?: try {
        guard case .file(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .voice?: try {
        guard case .voice(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .video?: try {
        guard case .video(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .location?: try {
        guard case .location(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .link?: try {
        guard case .link(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .receipt?: try {
        guard case .receipt(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .reply?: try {
        guard case .reply(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .preview?: try {
        guard case .preview(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .recall?: try {
        guard case .recall(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .transfer?: try {
        guard case .transfer(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .invite?: try {
        guard case .invite(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .notice?: try {
        guard case .notice(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .extra?: try {
        guard case .extra(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case nil: break
      }
      try { if let v = _storage._thread {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      if _storage._encrypted != false {
        try visitor.visitSingularBoolField(value: _storage._encrypted, fieldNumber: 32)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_Message, rhs: Bytedesk_Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mid != rhs_storage._mid {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._client != rhs_storage._client {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._thread != rhs_storage._thread {return false}
        if _storage._encrypted != rhs_storage._encrypted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bytedesk_MessageList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bytedesk_MessageList, rhs: Bytedesk_MessageList) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
