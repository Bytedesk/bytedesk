/*
 * @Author: jackning 270580156@qq.com
 * @Date: 2025-03-24 09:00:00
 * @LastEditors: jackning 270580156@qq.com
 * @LastEditTime: 2025-04-04 10:24:00
 * @Description: bytedesk.com https://github.com/Bytedesk/bytedesk
 *   Please be aware of the BSL license restrictions before installing Bytedesk IM – 
 *  selling, reselling, or hosting Bytedesk IM as a service is a breach of the terms and automatically terminates your rights under the license. 
 *  Business Source License 1.1: https://github.com/Bytedesk/bytedesk/blob/main/LICENSE 
 *  contact: 270580156@qq.com 
 * 
 * Copyright (c) 2025 by bytedesk.com, All Rights Reserved. 
 */
package com.bytedesk.ticket.thread.delegate;

import org.flowable.engine.delegate.DelegateExecution;
import org.flowable.engine.delegate.JavaDelegate;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * 客服会话满意度评价服务
 * 
 * 处理客服会话结束时的满意度评价功能
 * - 发送满意度调查
 * - 收集满意度评价数据
 * - 处理评价反馈
 */
@Slf4j
@Component("threadSatisfactionServiceDelegate")
public class ThreadSatisfactionServiceDelegate implements JavaDelegate {

    @Override
    public void execute(DelegateExecution execution) {
        String processInstanceId = execution.getProcessInstanceId();
        log.info("Satisfaction evaluation for thread process: {}", processInstanceId);
        
        // 获取流程变量
        String threadUid = (String) execution.getVariable("threadUid");
        String visitorId = (String) execution.getVariable("visitorId");
        String agentId = (String) execution.getVariable("agentId");
        
        // 记录满意度评价开始时间
        long startTime = System.currentTimeMillis();
        execution.setVariable("satisfactionStartTime", startTime);
        
        try {
            // 发送满意度调查
            boolean surveyDelivered = sendSatisfactionSurvey(threadUid, visitorId, agentId);
            execution.setVariable("satisfactionSurveyDelivered", surveyDelivered);
            
            if (surveyDelivered) {
                log.info("Satisfaction survey delivered for thread: {}, visitor: {}, agent: {}", 
                    threadUid, visitorId, agentId);
                
                // 设置超时时间，等待用户评价
                execution.setVariable("satisfactionWaitTimeout", 3600); // 秒
                
                // 模拟用户反馈
                Map<String, Object> feedbackData = simulateUserFeedback();
                processUserFeedback(execution, feedbackData);
            } else {
                log.warn("Failed to deliver satisfaction survey for thread: {}", threadUid);
                execution.setVariable("satisfactionStatus", "SURVEY_DELIVERY_FAILED");
            }
        } catch (Exception e) {
            log.error("Error in satisfaction evaluation service", e);
            execution.setVariable("satisfactionError", e.getMessage());
            execution.setVariable("satisfactionStatus", "FAILED");
        } finally {
            // 记录满意度评价结束时间和总时长
            long endTime = System.currentTimeMillis();
            execution.setVariable("satisfactionEndTime", endTime);
            execution.setVariable("satisfactionDuration", endTime - startTime);
            execution.setVariable("satisfactionTime", new Date());
        }
    }
    
    /**
     * 发送满意度调查
     */
    private boolean sendSatisfactionSurvey(String threadUid, String visitorId, String agentId) {
        // TODO: 实际项目中，这里应该实现发送满意度调查的逻辑
        log.info("Sending satisfaction survey for thread: {}, visitor: {}", threadUid, visitorId);
        
        // 模拟发送过程
        try {
            Thread.sleep(300);
            return true;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
    
    /**
     * 模拟用户反馈数据
     */
    private Map<String, Object> simulateUserFeedback() {
        // TODO: 实际项目中，这里应该等待并获取真实的用户反馈
        
        // 模拟用户反馈过程
        try {
            // 随机等待一段时间，模拟用户填写评价
            Thread.sleep(500 + (int)(Math.random() * 1000));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 模拟评分和反馈内容
        Map<String, Object> feedback = new HashMap<>();
        
        // 生成1-5的随机评分
        int rating = 3 + (int)(Math.random() * 3); // 倾向于生成较高分数
        feedback.put("rating", rating);
        
        // 根据评分生成反馈内容
        String[] positiveComments = {
            "服务很专业，解决了我的问题",
            "客服态度很好，回复也很快",
            "问题解决得很满意",
            "非常感谢客服的耐心解答"
        };
        
        String[] negativeComments = {
            "等待时间太长",
            "没有完全解决我的问题",
            "回复速度可以再快一点",
            "希望能提供更详细的解决方案"
        };
        
        if (rating >= 4) {
            int commentIndex = (int)(Math.random() * positiveComments.length);
            feedback.put("comment", positiveComments[commentIndex]);
            feedback.put("sentiment", "POSITIVE");
        } else if (rating == 3) {
            feedback.put("comment", "服务基本满意");
            feedback.put("sentiment", "NEUTRAL");
        } else {
            int commentIndex = (int)(Math.random() * negativeComments.length);
            feedback.put("comment", negativeComments[commentIndex]);
            feedback.put("sentiment", "NEGATIVE");
        }
        
        // 是否愿意再次提供反馈
        feedback.put("willFeedbackAgain", Math.random() > 0.3);
        
        return feedback;
    }
    
    /**
     * 处理用户反馈
     */
    private void processUserFeedback(DelegateExecution execution, Map<String, Object> feedbackData) {
        // 检查是否有反馈数据
        if (feedbackData == null || feedbackData.isEmpty()) {
            execution.setVariable("satisfactionStatus", "NO_FEEDBACK");
            return;
        }
        
        // 获取反馈数据
        int rating = (int) feedbackData.get("rating");
        String comment = (String) feedbackData.get("comment");
        String sentiment = (String) feedbackData.get("sentiment");
        boolean willFeedbackAgain = (boolean) feedbackData.get("willFeedbackAgain");
        
        // 存储反馈数据到流程变量
        execution.setVariable("satisfactionRating", rating);
        execution.setVariable("satisfactionComment", comment);
        execution.setVariable("satisfactionSentiment", sentiment);
        execution.setVariable("satisfactionWillFeedbackAgain", willFeedbackAgain);
        
        // 记录满意度状态
        if (rating >= 4) {
            execution.setVariable("satisfactionStatus", "SATISFIED");
        } else if (rating == 3) {
            execution.setVariable("satisfactionStatus", "NEUTRAL");
        } else {
            execution.setVariable("satisfactionStatus", "UNSATISFIED");
            
            // 对于不满意的评价，可能需要特别处理
            handleUnsatisfiedFeedback(execution, feedbackData);
        }
        
        log.info("Processed satisfaction feedback for thread: {}, rating: {}, sentiment: {}", 
            execution.getVariable("threadUid"), rating, sentiment);
    }
    
    /**
     * 处理不满意的反馈
     */
    private void handleUnsatisfiedFeedback(DelegateExecution execution, Map<String, Object> feedbackData) {
        // TODO: 实际项目中，这里应该实现处理不满意反馈的逻辑
        // 例如：通知主管、安排后续跟进等
        
        String threadUid = (String) execution.getVariable("threadUid");
        String agentId = (String) execution.getVariable("agentId");
        String comment = (String) feedbackData.get("comment");
        
        log.warn("Unsatisfied feedback for thread: {}, agent: {}, comment: {}", 
            threadUid, agentId, comment);
        
        // 设置后续跟进标志
        execution.setVariable("satisfactionNeedsFollowUp", true);
        execution.setVariable("satisfactionFollowUpReason", "Customer unsatisfied: " + comment);
    }
}